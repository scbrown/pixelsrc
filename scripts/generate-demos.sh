#!/usr/bin/env bash
# =============================================================================
# Demo Generator Script (DT-16)
#
# Parses @demo annotations from tests/demos/**/*.rs, extracts JSONL content,
# and generates markdown documentation fragments.
#
# Usage: ./scripts/generate-demos.sh [--dry-run]
#
# Annotations supported:
#   /// @demo section/subsection#anchor
#   /// @title Demo Title
#   /// @description Description text.
#   /// @cli pxl render example.jsonl -o output.png
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
TESTS_DIR="$PROJECT_ROOT/tests/demos"
EXAMPLES_DIR="$PROJECT_ROOT/examples/demos"
OUTPUT_DIR="$PROJECT_ROOT/target/demos"

# Color output (if terminal)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

DRY_RUN=false
if [[ "${1:-}" == "--dry-run" ]]; then
    DRY_RUN=true
fi

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Parse a single test file and extract demo metadata
# Output: TAB-separated records for each demo found
# Uses external AWK script for BSD awk compatibility
parse_test_file() {
    local file="$1"
    awk -f "$SCRIPT_DIR/parse_demos.awk" "$file"
}

# Generate markdown for a demo
generate_demo_markdown() {
    local demo="$1"
    local title="$2"
    local description="$3"
    local cli="$4"
    local jsonl_path="$5"

    # Replace <EMPTY> placeholders with empty string
    [[ "$title" == "<EMPTY>" ]] && title=""
    [[ "$description" == "<EMPTY>" ]] && description=""
    [[ "$cli" == "<EMPTY>" ]] && cli=""

    local jsonl_file="$PROJECT_ROOT/$jsonl_path"

    if [[ ! -f "$jsonl_file" ]]; then
        log_warn "JSONL file not found: $jsonl_path"
        return 1
    fi

    # Extract anchor from demo path (format: section/subsection#anchor)
    local anchor="${demo##*#}"
    local section="${demo%#*}"

    echo "## $title"
    echo ""
    if [[ -n "$description" ]]; then
        echo "$description"
        echo ""
    fi

    echo '<div class="demo-source">'
    echo ""
    echo '```jsonl'
    cat "$jsonl_file"
    echo '```'
    echo ""
    echo '</div>'
    echo ""

    echo "<div class=\"demo-container\" data-demo=\"$anchor\">"
    echo '</div>'
    echo ""

    if [[ -n "$cli" ]]; then
        echo '**CLI equivalent:**'
        echo '```bash'
        echo "$cli"
        echo '```'
        echo ""
    fi
}

# Get unique sections from demo data
get_sections() {
    local demos_data="$1"
    echo "$demos_data" | while IFS=$'\t' read -r marker demo title description cli jsonl_path; do
        [[ "$marker" != "DEMO" ]] && continue
        # Extract section (everything before #anchor)
        echo "${demo%#*}"
    done | sort -u
}

# Get demos for a specific section
# Note: Keeps <EMPTY> placeholders intact for bash read compatibility
get_demos_for_section() {
    local demos_data="$1"
    local target_section="$2"
    echo "$demos_data" | while IFS=$'\t' read -r marker demo title description cli jsonl_path; do
        [[ "$marker" != "DEMO" ]] && continue
        local section="${demo%#*}"
        if [[ "$section" == "$target_section" ]]; then
            printf "%s\t%s\t%s\t%s\t%s\n" "$demo" "$title" "$description" "$cli" "$jsonl_path"
        fi
    done
}

# Group demos by section and generate output files
process_demos() {
    local demos_data="$1"

    # Get unique sections
    local sections
    sections=$(get_sections "$demos_data")

    # Generate output for each section
    while IFS= read -r section; do
        [[ -z "$section" ]] && continue

        # Convert section path to file path (format/css/colors -> format_css_colors.md)
        local output_file
        output_file=$(echo "$section" | tr '/' '_').md
        local output_path="$OUTPUT_DIR/$output_file"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "[DRY-RUN] Would generate: $output_path"
            continue
        fi

        log_info "Generating: $output_path"

        {
            echo "<!-- Generated by scripts/generate-demos.sh -->"
            echo "<!-- Do not edit manually - regenerate with: ./scripts/generate-demos.sh -->"
            echo ""
            echo "# ${section##*/} Demos"
            echo ""

            get_demos_for_section "$demos_data" "$section" | while IFS=$'\t' read -r demo title description cli jsonl_path; do
                generate_demo_markdown "$demo" "$title" "$description" "$cli" "$jsonl_path"
            done

        } > "$output_path"

        log_success "Generated: $output_path"
    done <<< "$sections"
}

# Main
main() {
    log_info "Demo Generator Script (DT-16)"
    log_info "Project root: $PROJECT_ROOT"

    # Ensure output directory exists
    if [[ "$DRY_RUN" == "false" ]]; then
        mkdir -p "$OUTPUT_DIR"
    fi

    # Find all test files
    local test_files=()
    while IFS= read -r -d '' file; do
        test_files+=("$file")
    done < <(find "$TESTS_DIR" -name "*.rs" -print0 2>/dev/null || true)

    if [[ ${#test_files[@]} -eq 0 ]]; then
        log_warn "No test files found in $TESTS_DIR"
        exit 0
    fi

    log_info "Found ${#test_files[@]} test file(s)"

    # Parse all test files
    local all_demos=""
    local demo_count=0

    for file in "${test_files[@]}"; do
        local file_demos
        file_demos=$(parse_test_file "$file")
        if [[ -n "$file_demos" ]]; then
            all_demos+="$file_demos"$'\n'
            local count
            count=$(echo "$file_demos" | grep -c "^DEMO" || true)
            demo_count=$((demo_count + count))
            log_info "Parsed $(basename "$file"): $count demo(s)"
        fi
    done

    if [[ $demo_count -eq 0 ]]; then
        log_warn "No @demo annotations found"
        exit 0
    fi

    log_info "Total demos found: $demo_count"

    # Process and generate output
    process_demos "$all_demos"

    log_success "Done! Output in: $OUTPUT_DIR"
}

main "$@"
